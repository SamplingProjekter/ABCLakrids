---
title: "ABCLakrids"
author: "Smilk"
date: "13 sep 2018"
output: pdf_document
fig_caption: yes
---

## Introduktion til data og metode
Simon har samplet 4 poser ABC lakrids fra haribo fra en kvikly (her kan man overveje samplemetoden).
Poserne er samplet ud af af en population vi kan kalde ABC lakridser produceret til Danmark, hvor populationen (N) formodes at være meget stor, hvorved vi må antage at 1/N og n/N er 0. 
I samplet har vi oberveret hvilke bogstav hver enhed har. Således er interessevariablen en indikator funktion som kan tage 29 værdier.
Vi har dog måttet sande at vi ikke har observeret ø eller å og at det er umuligt at skeldne mellem M og W og Z og N, da det ikke fremgår klart hvordan de respektive bogstaver bør se ud. 
For at gøre dette så neutralt som mulig, og stadig gøre det muligt at lave beregninger, har vi valgt at antage, bogstaver som kan kategorizeres som to værdier fordeles til halv halv, og at de bogstaver som ikke er observeret ikke forekommer i totalpopulationen. 
Hver pose betragtes som en sample, af størrelse n (stokastisk værdi afhænger af vægten, da antallet af bogstaver varierer i hver pose). Det gennemsnitlige antal bogstaver pr pose er 80 (mere præcist 79.75 men vi kan ikke observerer halve bogstaver) 

## Overvejelser sammenlignet med alfabetet.
```{R, echo=FALSE, fig.width=10, fig.height=3.5, fig.cap="\\label{fig:figs} Bogstaver samplet fra de forskellige poser. Hver farvet bar indikerer en pose. Den sorte linje (L. Mean) viser gennemsnittet for hver bogstav over de 4 poser, mens den røde linje angiver gennemsnittet over alle bogstaver på tværs af poser"}
# Read data
Dat <- as.matrix(read.table("Data.R", sep="",head=TRUE,fill = TRUE))
#Formate data as matrix
Dat_new <- na.omit(matrix(as.numeric(Dat[,-1]),ncol=4,nrow=29))
rownames(Dat_new) <- Dat[-c(28,29),1]

# Sample size
n <- colSums(Dat_new)
n_mean <- sum(Dat_new)/4

# Plot data
mean <- apply(Dat_new,1,mean)
df <- barplot(t(Dat_new),beside=TRUE,col = rainbow(4))
lines(df,rep(mean,each=4),lty=2,lwd=1)
lines(df,rep(mean(mean),each=length(df)),lty=2,col="red")
legend("topleft",c("L. Mean","T. Mean"),lty = 2,col=c("black","red"))
```

Hvis vi ønsker at skrive et bestemt ord, kræver det ofte (i alt fald på dansk) at vi har en rimmelig mængde af vokaler til rådighed. Lad derfor y_v(i) betegne indikatorfunktionen for at individ i er en en vokal.
Fra dette finder vi (jvf Corollary 2.13) at y bar inden for hver pose er den empiriske varians 0.0025 0.0024 0.0025 og 0.0025 for hhv. pose 1, 2, 3 og 4. med konfidens interval for hver af de givne poser som følgende.
```{R}
id <- ifelse(rownames(Dat_new)%in% c("A","E","I",
                                    "O","U","Y",
                                    "AE"), TRUE,FALSE)
y_bar <- colSums(Dat_new[id,])/n
var_emp <- (1-0)*y_bar*(1-y_bar)/(n-1)
uu <- qnorm(.975)
CI <- cbind(y_bar-uu*sqrt(var_emp),y_bar+uu*sqrt(var_emp))
round(CI,2)
```


Til sammenligning forventer vi at det danske alphabet med 27 bogstaver (ink. W ekls. ø og å) og 7 vokaler har en forekomst af vokaler på 0.26. vi forkaster altså ikke, at fordelingen af vokaler og konsonanter i vores stikprøver afviger fra afabetet.


Ifølge sproget.dk (https://sproget.dk/temaer/ord-og-bogstaver/hvad-er-de-mest-almindelige-bogstaver-pa-dansk#kilder-kjeld-kristensen-bogstavernes d. 13/9) forekommer bogstaverne e, n, d og r hyppigere end andre bogstaver i alphabetet. 
Lad os derfor gøre tilsvarende som ovenfor for at undersøge om disse forekommer i en frekvens der minder om alfabetet eller, hvis poserne er designet til at man kan stave ord, vil vi forvente disse forekommer oftere end andre bogstaver. 
```{R}
id2 <- ifelse(rownames(Dat_new)%in% c("E","N","D","R"), 
                 TRUE,FALSE)
y_endr <- colSums(Dat_new[id2,])/n
var_endr <- y_endr*(1-y_endr)/(n-1)

CI <- cbind(y_endr-uu*sqrt(var_endr),y_endr+uu*sqrt(var_endr))
round(CI,2)
```

Med 4/27 aproksimativt lig 0.15 indeholdt i samtlige konfidensintervaller. Vi kan altså ikke forkaste at e, n, d og r ikke forekommer med samme hyppighed som i alfabetet. 

## Test for uniform fordeling af bogstaverne.
Vi vil nu teste hypotesen, at bogstaveren er uniform fordelte, dvs. om vi kan antage, at der er nogenlunde det samme antal af hver bogstav i en pakke. Vi vil hertil begynde med at betragte et histogram, som viser en fordeling af vores stikprøve. Et barplot summer over antallet af de forskellige bogstaver i \texttt{Dat\_new} og viser således et histogram af de observerede bogstaver.
```{R, echo=FALSE, fig.width=10, fig.height=4.5, fig.cap="\\label{fig:figs} Histogram som viser fordelingen af vores stikprøve. Hver farve indikerer en pose."}
barplot(t(Dat_new[-(28:29),]), col = rainbow(4))
```

Ud fra histogrammet kan vi ikke udelukke en uniform fordeling af bogstaverne. Vi vil nu bruge Kolomogorov-Smirnov testen til at finde en sandsynlighed for, at bogstaverne er uniform fordelte. Hertil finder vi en vektor, der indeholder tallene fra 1 til 27, som henholdsvis repræsenterer der observerede bogstaver fra \texttt{A} til \texttt{Æ}.
```{R}
Dat_new2 <- Dat_new[-(28:29),]
let <- integer(sum(Dat_new2))
i = 1

for (k in 1:4){
  for (j in 1:27){
    while (Dat_new2[j,k] > 0){
      let[i] = j
      Dat_new2[j,k] = Dat_new2[j,k] - 1
      i = i+1
    }
  }
}

suppressWarnings(ks.test(let, "punif", 1, 27))
```
Sandsynligheden $p = 0.179$ argumenterer dog ikke særlig stærk for en uniform fordeling af tallene.\newline
Som nævnt, så er der ingen forskel mellem bogstaverne \texttt{M} og \texttt{W}. Vi vil derfor gentage Kolomogorov-Smirnov testen, hvor vi først lægger antallene af observerede \texttt{M}'er og \texttt{W}'er sammen. I den følgende kodestump bliver \texttt{W} transformeret til \texttt{M}. Derefter kører vi \texttt{ks.test}.
```{R}
for (i in 1:324){
  if (let[i] == 23){
    let[i] <- 13
  }
}

suppressWarnings(ks.test(let, "punif", 1,27))
```
Sandsynligheden $p = 0.4266$ er allerede et meget stærkere argument for en uniform fordeling. Hvis \texttt{M} og \texttt{W} antages at være den samme bogstav, vil vi derfor ikke forkaste hypotesen om en uniform fordeling.


## Test mere?

## Konklusion